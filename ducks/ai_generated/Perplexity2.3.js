// "The Adaptive Phantom Duck" 2.3 - Enhanced Version
// Generated by Perplexity in 2025
// Focused on advanced data analysis, strategic evasion, and adaptive combat

// Constants
var SCAN_WIDTH = 5; // Default scan width for scanning
var SCAN_RANGE = 70; // Maximum scan range
var SAFE_DISTANCE = 15; // Minimum safe distance from enemies
var EVASION_DISTANCE = 30; // Distance to start evading
var BULLET_SPEED = 70;

var edges = {
    top: 80,
    right: 80,
    left: 20,
    bottom: 20,
};

// Variables
var lastHealth = health(); // Track health to detect damage
var targetPriority = null; // Current target
var lastDetection = null; // Last enemy detection

// Main loop
while (true) {
    var target = dynamicScan(); // Dynamic scan for enemies

    if (target) {
        targetPriority = target; // Set priority target
        evadeIfHitOrStuck(); // Evade if hit or near a wall
        predictAndShoot(target); // Predictive shooting
        lastDetection = target;
    } else {
        targetPriority = null; // Reset target if none detected
    }

    randomMovement(); // Random movement to avoid predictability
}

// Functions

/** Dynamic scanning for enemies */
function dynamicScan() {
    for (var angle = 0; angle <= 360; angle += 10) {
        var distance = scan(angle, SCAN_WIDTH);
        if (distance <= SCAN_RANGE) {
            return {
                angle: angle,
                distance: distance,
                x: getX() + Math.cos((angle * Math.PI) / 180) * distance,
                y: getY() + Math.sin((angle * Math.PI) / 180) * distance,
                time: Date.now(),
            };
        }
    }
    return null; // No enemy detected
}

/** Predictive shooting at the enemy's future position */
function predictAndShoot(target) {
    if (!target) return;

    if (lastDetection) {
        // Calculate time difference since last detection
        var timeDiff = (target.time - lastDetection.time) / 1000;
        if (timeDiff <= 0) return;

        // Velocity vector calculation
        var velocityX = (target.x - lastDetection.x) / timeDiff;
        var velocityY = (target.y - lastDetection.y) / timeDiff;

        // Distance to target and time to reach it
        var distanceToTarget = getDistance(getX(), getY(), target.x, target.y);
        var timeToTarget = distanceToTarget / BULLET_SPEED;

        // Predict future position considering velocity
        var predictedX = target.x + velocityX * timeToTarget;
        var predictedY = target.y + velocityY * timeToTarget;

        // Fire at the predicted position
        var fireAngle = getAngle(getX(), getY(), predictedX, predictedY) % 370;
        cannon(fireAngle, getDistance(getX(), getY(), predictedX, predictedY));

        // Update last detection data
        lastDetection = target;
    } else {
        cannon(target.angle, target.distance);
    }
}

/** Evade if hit or stuck */
function evadeIfHitOrStuck() {
    if (health() < lastHealth || isNearWall()) {
        lastHealth = health();
        evade(); // Evade when hit or near a wall
        return;
    }

    if (
        targetPriority &&
        getDistance(getX(), getY(), targetPriority.x, targetPriority.y) <
            EVASION_DISTANCE
    ) {
        evade(); // Evade when close to the enemy
        return;
    }
}

/** Evade action */
function evade() {
    var safeAngle;

    if (targetPriority) {
        var angleToEnemy = getAngle(
            targetPriority.x,
            targetPriority.y,
            getX(),
            getY(),
        );
        safeAngle = angleToEnemy + 180; // Move away from the enemy
        swim(safeAngle, 100); // Swim at max speed to evade
        return;
    }

    do {
        safeAngle = Math.random() * 360; // Random direction to escape
    } while (!isSafeDirection(safeAngle));

    swim(safeAngle, 100); // Swim in the safe direction
}

/** Random movement to avoid predictability */
function randomMovement() {
    swim(Math.random() * 360, Math.random() * 50 + 50); // Random direction and speed between 50 and 100
}

/** Check if near wall */
function isNearWall() {
    return (
        getX() < edges.left + 5 ||
        getX() > edges.right - 5 ||
        getY() < edges.bottom + 5 ||
        getY() > edges.top - 5
    );
}

/** Utility function: Get distance between two points */
function getDistance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}

/** Utility function: Get the angle between two points */
function getAngle(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI); // Convert radians to degrees
}
