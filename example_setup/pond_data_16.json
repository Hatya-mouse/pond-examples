{
  "settings": {
    "game": {
      "fps": 50,
      "tps": 50,
      "volume": 1
    },
    "viewport": {
      "width": 100,
      "height": 100,
      "backgroundColor": "#527dbf"
    },
    "duck": {
      "billColor1": "#ffcb02",
      "billColor2": "#ffbd00",
      "circleColor": "#222222",
      "outerEyeColor": "#151515",
      "innerEyeColor": "#f0f0f0"
    },
    "ducks": [
      {
        "id": 1,
        "name": "Player",
        "loc": {
          "x": 80.0,
          "y": 50.0
        },
        "color": "#ff9c00",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 2,
        "name": "Rook",
        "loc": {
          "x": 77.72,
          "y": 61.48
        },
        "color": "#da0026",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 3,
        "name": "Sniper",
        "loc": {
          "x": 71.21,
          "y": 71.21
        },
        "color": "#334079",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 4,
        "name": "Counter",
        "loc": {
          "x": 61.48,
          "y": 77.72
        },
        "color": "#277d1c",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 5,
        "name": "Eagle",
        "loc": {
          "x": 50.0,
          "y": 80.0
        },
        "color": "#d2b27a",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 6,
        "name": "Alligator",
        "loc": {
          "x": 38.52,
          "y": 77.72
        },
        "color": "#3d905b",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 7,
        "name": "Phantom",
        "loc": {
          "x": 28.79,
          "y": 71.21
        },
        "color": "#674777",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 8,
        "name": "Tank",
        "loc": {
          "x": 22.28,
          "y": 61.48
        },
        "color": "#46493a",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 9,
        "name": "Mallard",
        "loc": {
          "x": 20.0,
          "y": 50.0
        },
        "color": "#417505",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 10,
        "name": "Wood Duck",
        "loc": {
          "x": 22.28,
          "y": 38.52
        },
        "color": "#663b0f",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 11,
        "name": "American Wigeon",
        "loc": {
          "x": 28.79,
          "y": 28.79
        },
        "color": "#e9d395",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 12,
        "name": "Pekin Duck",
        "loc": {
          "x": 38.52,
          "y": 22.28
        },
        "color": "#c7cac3",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 13,
        "name": "Gadwall",
        "loc": {
          "x": 50.0,
          "y": 20.0
        },
        "color": "#a09b92",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 14,
        "name": "Hooded Merganser",
        "loc": {
          "x": 61.48,
          "y": 22.28
        },
        "color": "#473919",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 15,
        "name": "Aylesbury Duck",
        "loc": {
          "x": 71.21,
          "y": 28.79
        },
        "color": "#e9e9e9",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      },
      {
        "id": 16,
        "name": "Black-Bellied Whistling Duck",
        "loc": {
          "x": 77.72,
          "y": 38.52
        },
        "color": "#3a3a3a",
        "script": "// Player 10.1 \"The Relentless Duck\" (Very very extremely strong)\n// Redesigned from scratch to achieve more efficient processing.\n\n// ——— Constants ———\n\n// 35 units in 0.5s\n// -> 70units/s\nvar bulletSpeed = 70;\n\n// Measure cannon speed\n// var startTime = Date.now();\n// cannon(0, 70);\n// while (true) {\n//     log(Date.now() - startTime);\n// }\n\nvar edges = {\n    top: 80,\n    right: 80,\n    left: 20,\n    bottom: 20\n};\n\nvar corners = [\n    { x: 0, y: 0 },\n    { x: 0, y: 100 },\n    { x: 100, y: 0 },\n    { x: 100, y: 100 }\n];\n\n// ——— Variables ———\n\nvar d = damage();\n\nvar scanData = {\n    start: 0,\n    end: 360,\n    range: 20,\n    step: 20\n};\n\nvar swimInfo = {\n    baseAngle: 0,\n    x: 50,\n    y: 50\n};\n\nvar oldDetection = null;\nvar latestDetection = null;\nvar result = null;\n\nvar count = 0;\n\nvar lastCannonTime = 0;\n\n// ——— Main loop ———\n\nwhile (true) {\n    result = wideScan(scanData.start, scanData.end, scanData.range, scanData.step);\n\n    // If enemy detected\n    if (result.distance <= 70) {\n        runManeuver(result, latestDetection);\n        if (result.error <= 5) {\n            oldDetection = latestDetection;\n            latestDetection = result;\n            deflectionCannon(result, oldDetection);\n        } else {\n            cannon(result.angle, result.distance);\n            lastCannonTime = Date.now();\n        }\n    }\n\n    runManeuver(result, latestDetection);\n\n    scanData = setupScan(result);\n}\n\n// ——— Functions ———\n\n/** Performs wide scan */\nfunction wideScan(start, end, range, step) {\n    for (var angle = start; angle <= end; angle += step) {\n        var distance = scan(angle, range);\n        if (distance <= 70) {\n            return {\n                angle: angle,\n                distance: distance,\n                x: getX() + Math.cos(angle * Math.PI / 180) * distance,\n                y: getY() + Math.sin(angle * Math.PI / 180) * distance,\n                scanX: getX(),\n                scanY: getY(),\n                error: range,\n                time: Date.now()\n            };\n        }\n    }\n\n    // If nothing detected, return only scan information.\n    return {\n        angle: angle,\n        distance: Infinity,\n        scanX: getX(),\n        scanY: getY(),\n        error: range,\n        time: Date.now()\n    };\n}\n\nfunction deflectionCannon(scanData, oldScanData) {\n    if (!scanData) return; // Check if scanData is null\n    var firePos = {\n        x: scanData.x,\n        y: scanData.y\n    };\n    if (oldScanData !== null) {\n        var timeDiff = scanData.time - oldScanData.time;\n        if (timeDiff < 2000) {\n            // Predict the target's position\n            var predictedPos = predictPosition(scanData, oldScanData, bulletSpeed);\n            firePos = predictedPos;\n        }\n    }\n    firePos.x = clamp(firePos.x, 3, 97);\n    firePos.y = clamp(firePos.y, 3, 97);\n    var move = calculateMovement(firePos.x, firePos.y);\n    while (!cannon(move.angle, move.distance)) {\n        move = calculateMovement(firePos.x, firePos.y);\n        lastCannonTime = Date.now();\n    }\n}\n\n/** Prepare for the next scan */\nfunction setupScan(scanData) {\n    var min_range = 2;\n    var min_step = 2;\n    // Get the angle to the enemy\n    var angle = getAngle(getX(), getY(), scanData.x, scanData.y);\n    if (scanData && scanData.distance <= 70) {\n        return {\n            start: angle - Math.max(scanData.error, 3),\n            end: angle + Math.max(scanData.error, 3),\n            range: Math.max(scanData.error / 4, min_range),\n            step: Math.max(scanData.error / 4, min_step)\n        };\n    } else {\n        return {\n            start: scanData.angle - 20,\n            end: scanData.angle + 340,\n            range: 8,\n            step: 8\n        };\n    }\n}\n\nfunction runManeuver(scanData, lastScanData) {\n    if (!scanData) return; // Check if scanData is null\n    if (shouldRun(scanData)) {\n        count = 0;\n        d = damage();\n        if (scanData.distance <= 70) {\n            runFromCollision(scanData, lastScanData);\n        } else {\n            randomSwim();\n        }\n    }\n    count += 1;\n}\n\nfunction shouldRun(scanData) {\n    return speed() <= 0 || d != damage() || shouldStop() || count >= 3 || scanData.distance <= 50;\n}\n\n/** Check if the player is swimming into the enemy */\nfunction isGoingToEnemy() {\n    var angle = getAngle(getX(), getY(), swimInfo.x, swimInfo.y);\n    return speed() > 0 && scan(angle, 6) <= 70;\n}\n\nfunction runFromCollision(scanData, lastScanData) {\n    if (lastScanData !== null && lastScanData.distance <= 70 && !shouldStop()) {\n        var enemyPosition = {\n            x: scanData.x,\n            y: scanData.y\n        };\n        var farthestCorner = findFarthestCorner(enemyPosition);\n        var x = clamp(farthestCorner.x, 20, 80);\n        var y = clamp(farthestCorner.y, 20, 80);\n        var angle = getAngle(getX(), getY(), x, y);\n        if (scan(angle, 20) <= 50) {\n            var counter = 0;\n            while (scan(angle, 20) <= 50 && counter < 4) {\n                angle += 90;\n                counter++;\n            }\n        }\n        // Move to a safer position\n        swim(angle, 100);\n        swimInfo = { baseAngle: angle, x: x, y: y };\n    } else {\n        randomSwim();\n    }\n}\n\nfunction randomSwim() {\n    stop();\n    var x = Math.random() * 60 + 20;\n    var y = Math.random() * 60 + 20;\n    var angle = getAngle(getX(), getY(), x, y);\n    var counter = 0;\n    while ((getDistance(getX(), getY(), x, y) <= 25 || scan(angle, 20) <= 50) && counter < 5) {\n        x = Math.random() * 60 + 20;\n        y = Math.random() * 60 + 20;\n        angle = getAngle(getX(), getY(), x, y);\n        counter++;\n    }\n    swim(angle, 100);\n    swimInfo = { baseAngle: angle, x: x, y: y };\n}\n\nfunction shouldStop() {\n    return (getX() <= edges.left && swimInfo.x <= edges.left) ||\n        (getX() >= edges.right && swimInfo.x >= edges.right) ||\n        (getY() <= edges.bottom && swimInfo.y <= edges.bottom) ||\n        (getY() >= edges.top && swimInfo.y >= edges.top) ||\n        (getDistance(getX(), getY(), swimInfo.x, swimInfo.y) <= 8) ||\n        isGoingToEnemy();\n}\n\nfunction canFire() {\n    return Date.now() - lastCannonTime > 1000;\n}\n\n// ——— Utility functions ———\n\nfunction clamp(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/** Classical pythagorean distance formula */\nfunction getDistance(x1, y1, x2, y2) {\n    var x = x1 - x2;\n    var y = y1 - y2;\n    return Math.sqrt((x * x) + (y * y));\n}\n\nfunction getAngle(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\n}\n\nfunction calculateMovement(x, y) {\n    var fireAngle = getAngle(getX(), getY(), x, y);\n    var fireDistance = getDistance(getX(), getY(), x, y);\n    return { angle: fireAngle, distance: fireDistance };\n}\n\nfunction findFarthestCorner(enemyPosition) {\n    var farthestCorner = corners[0];\n    var maxDistance = getDistance(enemyPosition.x, enemyPosition.y, farthestCorner.x, farthestCorner.y);\n    for (var i = 1; i < corners.length; i++) {\n        var distance = getDistance(enemyPosition.x, enemyPosition.y, corners[i].x, corners[i].y);\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestCorner = corners[i];\n        }\n    }\n    return farthestCorner;\n}\n\nfunction predictPosition(current, last, bulletSpeed) {\n    // Time diff\n    var timeDiff = (current.time - last.time) / 1000; // Convert to seconds\n    if (timeDiff <= 0) {\n        timeDiff = 0.1; // Minimum value\n    }\n    // Speed of the enemy\n    var speedX = (current.x - last.x) / timeDiff;\n    var speedY = (current.y - last.y) / timeDiff;\n    // If it is supposed to be the same enemy (speed is below threshold)\n    if (getDistance(0, 0, speedX, speedY) < 80) {\n        // Moved distance of the enemy\n        var distance = getDistance(getX(), getY(), current.x, current.y);\n        // Estimated time for bullet to reach the enemy\n        var timeToTarget = distance / bulletSpeed;\n        // Target's predicted position\n        var predictedX = current.x + speedX * timeToTarget;\n        var predictedY = current.y + speedY * timeToTarget;\n        // Use the predicted distance and angle to fire\n        return {\n            x: predictedX,\n            y: predictedY\n        };\n    } else {\n        // If speed is too high, don't predict and just use the current position\n        return {\n            x: current.x,\n            y: current.y\n        };\n    }\n}\n"
      }
    ],
    "editor": {
      "tabWidth": 4
    }
  }
}
